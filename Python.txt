i=10
print(i)                            #returns 10

x1=22
y1=11
z1=x1/y1
print(z1)                           #retuns 2

name= 'avrajit'
len(name)                           #returns 7, (note: INDEX starts from '0')
name[2]                             #returns 'r'
name.upper                          #for upper-case
name[-3]                            #returns 'j', shows 3rd letter from the last

mylist = [30, 20, "avra"]           #LIST named as 'mylist' created, 3rd bracket signifies list
print(mylist)
mylist[1]                           #returns 20, as in python index starts from '0'                       
mylist[1] = 99                      #replace 20 by 99
print(mylist)                       #output: 30, 99, 'avra'
mylist.append(10)                   #adds '10' at the end of the list, if printed shows 30, 99, 'avra', 10
mylist.insert (2, 1000)             #inserts '1000' in the 3rd position
mylist.reverse()                    #to get mirror image of the list

dictionary_course = {1: "Python",
                     2: "R",
                     3: "SQL"}      

print(dictionary_course)                     #DICTIONARY created in the name of 'dictionary_course', 2nd bracket for dictionary
dictionary_course[1]                         #returns 'Python'
dictionary_course.get(1)                     #returns 'Python
dictionary_course[4] = "Hadoop"              #adds 'Hadoop' in the 4th position of the dictionary

tuple_animal = (10, 20, "tiger", "lion", "tiger", "cat")              #TUPLE named 'tuple_animal' created
tuple_animal.count("tiger")                                           #returns 2

myset = {10, 20, 30, "tiger", "cat", 10}                              #created a set named 'myset', for set 2nd bracket is required
print(myset)                                                          #returns (20, 'tiger', 10, 'cat', 30)

#TYPE CONVERSION
int()                             #changes any datatype to 'integer'
float()                           #changes any datatype to 'float'
str()                             #changes any datatype to 'charecter string'
tuple()                           #changes any datatype to 'tuple'
list()                            #changes any datatype to 'list'
set()                             #changes any datatype to 'set'
dict()                            #changes any datatype to 'dictionary'

#example
x2 = 12
name = "avrajit"
print (str(x2) + name)            #returns '12avrajit'

#COLLECTIONS in Python
from collections import namedtuple                              #implementing a namedtuple
ax = namedtuple("courses", "course_name, software")             #'course_name' not 'course name' else error
sx = ax("data science", "python")
print(sx)                                                       #returns 'courses(course name="datascience", software="python)'

from collections import namedtuple                              #implementing namedtuple from a list
ax = namedtuple("courses", "course_name, software")
sy = ax._make(["artificial I", "python"])                       #3rd bracket means list
print(sy)                                                       #'underscore' before 'make' is mandatory, returns 'courses(course name="artificial I", software="python)'

from collections import deque                                   #implementing deque
ax1 = ["v", "r", "a", "j"]                                      #list created in the name of 'ax1'
sx1 = deque(ax1)                                                #coverting list into deque
print(sx1)                                                      #returns 'deque("v", "r", "a", "j")
sx1.append("i")                                                 #adds "i" at the end of the deque
sx1.appendleft("a")                                             #adds "a" in the begining
sx1.pop()                                                       #removes "i" from the end
sx1.popleft()                                                   #removes "a" from the begining

from collections import ChainMap                                #python is case sensitive, so write 'ChainMap' carefully
ax2 = {1:"avra", 2:"deepu"}                                      
ay2 = {3:"soumava", 4:"ankana"}                                 #2 dictionaries named ax2 & ay2 were created
sx2 = ChainMap(ax2, ay2)                                        #ChainMapped them into one
print(sx2)

from collections import Counter                                 #'C' of 'Counter' should be in upper-case
ax3 = [1,1,2,3,1,3,2,3,1,4,4,3,4,6,2]                           #list of numbers created with duplicate values
sx3 = Counter(ax3)                                              #to count number of '1, 2, 3, 4, 6' in decending order of repeatations
print(sx3)                                                      #returns 'Counter({1: 4, 3: 4, 2: 3, 4: 3, 6: 1})'
print(list(sx3.elements()))                                     #returns back all values present in the list, '[1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 6]'
print(sx3.most_common())                                        #returns '[(1, 4), (3, 4), (2, 3), (4, 3), (6, 1)]'
cx3 = {1:2, 3:1, 6:1}                                           #assigned a dictionary for using 'subtraction'
print(sx3.subtract(cx3))                                        #subtracting dictionary 'cx3' from 'sx3'
print(sx3.most_common())                                        #subtracted, o/p- '[(2, 3), (3, 3), (4, 3), (1, 2), (6, 0)]'

from collections import OrderedDict                             #'O' & 'D' should be in 'caps'
dx = OrderedDict()                                              #defined an OrderedDict as 'dx'
dx[1] = "a"
dx[2] = "v"
dx[3] = "r"
dx[4] = "a"
dx[5] = "j"
dx[6] = "i"
dx[7] = "t"
print(dx)
print(dx.keys())                                                #returns 'odict_keys([1, 2, 3, 4, 5, 6, 7])'
print(dx.items())                                               #returns 'odict_items([(1, 'a'), (2, 'v'), (3, 'r'), (4, 'a'), (5, 'j'), (6, 'i'), (7, 't')])'

from collections import defaultdict                             #implementing defaultdict
dx2 = defaultdict(int)
dx2[1] = "python"
dx2[2] = "R"
print(dx2)                                                      #returns 'defaultdict(<class 'int'>, {1: 'python', 2: 'R'})'
print(dx2[3])                                                   #returns '0', as 'dx2' has no input. normal dictionary would show an error message instead

#ARRAYS (like vector in 'R', 3 methods are there)
import array                                                    #method 1
ax4 = array.array("i", [1,2,3,4,5,6])                           #'i' is the datatype of the datas present in the array
ax4

import array as ar                                              #method 2, 'ar' is the alias
ax5 = ar.array("i", [1,2,3,4,5,6])
ax5

from array import *                                             #method 3, '*' means all
ax6 = array("i", [1,2,3,4,5,6])
ax6
ax6[2]                                                          #returns '3'

#ARRAY OPERATIONS (length, adding elements, removing elements & slicing)
len(ax5)                                                        #returns 6, number of elements present in array
ax5.append(7)                                                   #adds 7 at the end of the array, returns 'array('i', [1, 2, 3, 4, 5, 6, 7])'
ax5.extend( [8,9,10] )                                          #adds '6,7,8' at the last of the array, returns 'array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])'
ax5.insert (2, 11)                                              #insert 11 at the '2nd index' or the '3rd value', returns 'array('i', [1, 2, 11, 3, 4, 5, 6, 7, 8, 9, 10])'
ax5.pop()                                                       #removes the last element from the array
ax5.pop(2)                                                      #removes the elemt in the '2nd index' i.e. the '3rd value', returns 'array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9])', removes 11
print(ax5[0:3])                                                 #only prints the 1st, 2nd & 3rd value (doesn't print the 'index 3' value), returns 'array('i', [1, 2, 3])'

#ARRAY CONCATENATION (create 2 arrays & an empty array to concatenate them)
import array as ara
ax7 = ara.array ("d", [1,2,3,4])                                #1st array created, 'd' for float value
ax8 = ara.array ("d", [5,6,7,8])                                #2nd array created, 'd' for float value
ax9 = ara.array ("d")                                           #empty array created to concatenate the above 2 arrays
ax9 = ax7 + ax8
print(ax9)

#LOOPING OF ARRAYS (for, while)
#for loop (when number of iterations are known)
for i1 in ax5:
    print(i1)                                                   #both commands must be typed and run in the same cell, else error

for i2 in ax5[0:3]:
    print(i2)                                                   #only after placing the ':', press enter, else will not run

#while loop (interation, condition, increment)
i3=0                                                            #iteration
while i3 < ax5[3]:                                              #condition to print only 4 values
    print(ax5[i3])                                              #if only 'i3' is printed then will only print the iterations
    i3=i3+1                                                     #increment

i4=0
while i4 < len(ax5):
    print(ax5[i4])                                              #to print all values = length of the array
    i4=i4+1

#CREATING DICTIONARIES (using 2 different methods (KEYS & VALUES)
my_dict = {"avra" : "001", "deepu" : "002"}                     #METHOD 1 - dictionary created, "avra" is the KEY, "001" is the value
print(my_dict)
type(my_dict)                                                   #returns 'dict'

my_dict1 = dict(avra ="001", deepu ="002")                      #METHOD 2 - dictionary created
print(my_dict1)
type(my_dict1)                                                  #returns 'dict'
                                                   
#CREATING NESTED DICTIONARY (dictionary inside a dictionary)
emp_dict = {"employee": {"avra": {"id":"001", "last_name":"dey", "salary":"2000"}, "deepu": {"id":"002", "last_name":"nayak", "salary":"3000"}}}
print(emp_dict)

#Operations on HASH-TABLES (KEYS & VALUES)
print(my_dict.keys())                                           #output "(['avra', 'deepu'])"
print(my_dict.values())                                         #output "(['001', '002'])"
print(my_dict.get("deepu"))                                     #output "002"

#Operations on hash-tables using LOOPS
for i5 in my_dict:
    print(i5)                                                   #only prinnts the keys by default, output "avra, deepu"

for i6 in my_dict.values():                                     #only print the values, output "001, 002"
    print(i6)

for i7 in my_dict.items():                                      #prints both
    print(i7)                                                   #output "('avra', '001'), ('deepu', '002')"

#UPDATING data in a dictionary
my_dict["avra"] = "003"                                         #replacing 'values' for a 'key'
my_dict["subha"] = "004"                                        #adding new 'values & keys' in a dictionary
print(my_dict)                                                  #output "{'avra': '003', 'deepu': '002', 'subha': '004'}"
my_dict.pop("deepu")                                            #deleting entries, output "{'avra': '003', 'subha': '004'}"
my_dict.popitem()                                               #remove the last entries (both keys & values)
del my_dict["subha"]                                            #deletes (both keys & values) for "subha"

#CONVERTING DICTIONARY into DATA FRAME
import pandas as ad                                             #'pandas' for data frame, 'ad' is an 'alias'
df = ad.DataFrame(emp_dict["employee"])                         #'ad' is the alias, 'emp_dict' was the NESTED DICTIONARY created earlier
print(df)                                                       #output like data frame table (like in R studio)

#Operations in Python (Arithmetic, Assignment, Comparision, Logical, Membership, Identity, Bit-wise) 
#Arithmetic
x2 = 10                                                         #'x2' variable is assigned a value of 10
y2 = 2                                                          #'y2' variable is assigned a value of 2
x2 + y2                                                         #addition
x2 - y2                                                         #substraction
x2 * y2                                                         #multiplication
x2 / y2                                                         #divison
x2 ** y2                                                        #to the Power (output- 10^2)
x2 // y2                                                        #integer divison (remainder discarded)
x2 % y2                                                         #modulo-division (only remainder is shown)

#Assignment
x2 = 10                                                         # 'x2' variable is assigned a value of 10
x3 += 10                                                        # "x3 = x3 + 10"
x4 -= 10                                                        # "x4 = x3 - 10"
x5 *= 10                                                        # "x5 = x3 * 10"
x6 /= 10                                                        # "x6 = x3 / 10"
x7 **= 10                                                       # "x7 = x3 ^ 10"

#Comparision ( == , != , > , < , >= , <= )
x8 = 20
y8 = 10
compare = x8 == y8                                              #variable 'compare' is assigned if x8 is equal to y8
print(compare)                                                  #returns 'False'

#Condition (if, else & else-if)
if x8 == y8:
    Print("equal")
elif x8 > y8:                                                   #else-if is written as "elif" in Python; allignment should be same as here, else error
         print("greater")
else:                                                           #allignment should be same as here
            print("smaller")

#Logical (AND, OR, NOT)
x8 > 20 and y8 > 5                                              #"AND" operator, should be in lower case, returns 'true' only if both statements are TRUE
x8 > 20 or y8 > 5                                               #returns TRUE, "OR" operator
not(x8 > 20 and y8 > 5)                                         #returns TRUE

Bit-wise (AND, OR, NOT(~), XOR, Left shift, Right shift)
10 & 12                                                         #"AND GATE"-returns 8 (1000), since 10 is (1010) and 12 is (1100), so result will be 1 only if both are 1s
10 | 12                                                         #"OR GATE"-returns 14 (1110), takes 1 if either of the numbers is 1 
10 ^ 12                                                         #"XOR GATE"- returns 6 (0110), if 'two' digits are similar, it takes '0'
12 >> 2                                                         #returns 3 (11), shifts the binary digits to right by 2, since 12 (1100), shifting right by 2 makes it (11)
12 << 2                                                         #returns 48 (110000), shifts the binary digits to left by 2

