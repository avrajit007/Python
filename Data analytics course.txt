#Creating a list and printing its items
x = [1, 2, "a", "b"]

for i in x:
    print(i)

#OR
i = 0
while i = len(x):
      print(x[i])
      i = i+1

#Slicing operation
x = "This is a string"
print (x[0:3])                                   #returns 'Thi'

x = 'Dr. Christopher Brooks'
print(x[4:15])                                   #returns 'Christopher', remember 'space' also has an index value

#Other operations with string
first_name = "Christopher"
last_name = "Brooks"
print(first_name + " " + last_name)              #Concatenation(+), returns 'Christopher Brooks'
print(first_name * 2)                            #repeatation(*), returns 'ChristopherChristopher'
print("Chris" in first_name)                     #search(in), returns 'True'

first_name = "Christopher Arthur Brooks".split(" ")[0]         #split based on space
last_name = "Christopher Arthur Brooks".split(" ")[-1]

#Dictionary
x = {1: "avra", 2: "christopher"}

for i in x.keys():
    print(x[i])                                  #returns '1, 2'

for i in x.values():
    print(x[i])                                  #returns 'avra, christopher'

for i, j in x.items():
    print(i,j)                                   #returns both key-value pairs

#Defining a variable - to add or substract
def do_math(a, b, kind):
  if (kind=='add'):
    return a+b
  else:
    return a-b
do_math(1, 2, 'add')

#Using Map function
people = ['Dr. Christopher Brooks', 'Dr. Kevyn Collins-Thompson', 'Dr. VG Vinod Vydiswaran', 'Dr. Daniel Romero']
def split_title_and_name (person):
    title = person.split()[0]
    lastname = person.split()[-1]
    return '{} {}'.format(title, lastname)
list(map(split_title_and_name, people))

#Using Lambda function
people = ['Dr. Christopher Brooks', 'Dr. Kevyn Collins-Thompson', 'Dr. VG Vinod Vydiswaran', 'Dr. Daniel Romero']
def split_title_and_name(person):
    return person.split()[0] + ' ' + person.split()[-1]
list(map(split_title_and_name, people)) == list(map(lambda person: person.split()[0] + ' ' + person.split()[-1], people))

#Datetime & Time function
import datetime as dt
import time as tm
tm.time()                                                          

dt_now = dt.datetime.fromtimestamp(tm.time())
dt_now

delta = dt.timedelta(days=100)                                  #100 days before today
today = dt.date.today()
print(today-delta)                                              #will print the date 100 days before

#NUMPY
import numpy as np
a = np.array([1,2,3])
print(a)
print(a.ndim)                                                         #returns '1'
print(a.shape)                                                        #returns (3,1)
print(a.dtype)                                                        #returns 'int32', one row takes 32 byte

b = np.ones((2,3))
b                                                                     #(2,3) matrix with all elements as '1'

c = np.random.rand(2,3)
print(c)

d = np.arange(10,20,2)                                                #output - 'array([10, 12, 14, 16, 18])'
d                                                                     #from 10 to 15 with difference of 2

e = np.linspace(10,15,10)                                             #10 numbers from 10 to 15
e                                                                     #LINSPACE - check spelling

farenheit = np.array([0, 37, 98, 103])
celcius = (farenheit + 32)/(1.8)
celcius

h = np.arange(1,16).reshape(3,5)                                      #elements 1-15, reshaped into (3,5)
h

#MATRIX MULTIPLICATION
f = np.array([[1,2], [3,4]])                                          #two [] brackets has to be present
g = np.array([[4,5], [6,7]])
print(f@g)                                                            #matrix multiplication, not element-wise multiplication

#IMAGE module from PIL(python image library)
from PIL import Image
from IPython.display import display
im = Image.open("C:/Users/Administrator/Downloads/rupsa.jpg")
display(im)                                                           #printing the image
pic_array = np.array(im)
print(pic_array)
print(pic_array.shape)                                                #output - '(800, 640, 3)'

mask = np.full(pic_array.shape, 255)                                  #to make all elements in the array as '255'
mask

modified_array = mask-pic_array                                       #substracting each element from (mask - pic_array)
modified_array = modified_array.astype(np.uint8)                      #this line is mandatory to display the new image
modified_array

display(Image.fromarray(modified_array))                              #image with different colour concentration

reshaped_array = np.reshape(modified_array, (200,150))                #only if black&White image
display(Image.fromarray(reshaped_array))

#Indexing
a = np.array([[1,2], [3,4], [5,6]])
a[1,1]                                                                #returns '4'

np.array([a[0,0], a[1,1], a[2,0]])                                    #(1,4,5)
#OR
np.array(a[[0,1,2], [0,1,0]])                                         #(1,4,5)

#Slicing
a = np.array([1,2,3,4,5])
print(a[:3])                                                          #donot print element(3), output-(1,2,3) 
print(a[2:4])                                                         #output - (3,4)

b = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
print(b[:2])                                                          #all elements from 1st-two rows, index '0 & 1'
print(b[:2, 1:3])                                                     #(2,3,6,7)
print(b[:, 0])                                                        #all rows & 1st column

#Datasets with Numpy
df = np.genfromtxt("C:/Users/Administrator/Downloads/vvv.txt")        #to load datasets from external 'csv OR txt' file
df

#REGEX (manipulating text)
import re                                                             #importing 'REGULAR EXPRESSION'
text = "this is a good day"
if re.search("good", text):
    print("Wonderfull")
else:
    print("Alas")                                                     #output- 'wonderfull'

text = "Amy works diligently. Amy gets good grades so students like Amy is successful"
re.findall("Amy", text)                                                                      #output- 'Amy Amy Amy'
re.split("Amy", text)                                                                        #output- '' works diligently. ', ' gets good grades so students like ', ' is successful''

#Patterns & charecter class
grades = "ACAAABCBCBAA"
re.findall("B", grades)                                               #output- 'B B B'
re.findall("AB", grades)                                              #only 1 'AB' is present in the string 'grades'
re.findall("[A][B-C]", grades)                                        #should start with 'A', after that either 'B' or 'C'
re.findall("[^A]", grades)                                            #['C', 'B', 'C', 'B', 'C', 'B'], shows results which is not 'A' 
re.findall("^[A]", grades)                                            #output- ['A'], begining with 'A'

#Using regex on text files & to understand quantifiers
import re
with open("C:/Users/Administrator/Downloads/ferpa.txt", "r") as f:
    wiki = f.read()                                                   #to read a text file called 'ferpa'
wiki

re.findall("[\w]*\[edit\]", wiki)                                     #find all the headings, as "[edit]" is present beside every heading, since txt from wikipedia
re.findall("[\w ]*\[edit\]", wiki)                                    #the previous one only found the last word before edit, but including space after '\w' the whole heading was found
for headings in re.findall("[\w ]*\[edit\]", wiki):
    print(re.split("[\[]", headings)[0])                              #only the headings were printed this time, not the '[edit]'

#OR same output using 'FINDITER' function
for item in re.finditer("([\w ]*)(\[edit\])", wiki):
    print(item.group(1))

#LOOK-AHEAD & LOOK-BEHIND







#Assignment-1 using regular expressions(regex)
import re
simple_string = ("Amy is 5 years old, and her sister Mary is 2 years old. Ruth and Peter, their parents, have 3 kids.")
def names (string):
    name = " ".join(re.findall(r"[A-Z]\w+", string))
    print(name)
    print(len(name.split()))
names(simple_string)

import re
with open ("C:/Users/Administrator/Downloads/vvv.txt", "r") as file:
    grades = file.read()
re.findall(re.escape("\n") + "(.*)" + re.escape(": B"), grades) 

import re
with open ("C:/Users/Administrator/Downloads/vvv.txt", "r") as file:
    logdata = file.read()
x = logdata.split("\n")
list_all=[] 
dict_log={} 
for item in x:
    pos_1=item.find(' - ')
    IP=item[:pos_1]
    username=re.findall(re.escape(' - ')+"(.*)"+re.escape(' ['),item)[0]
    date=re.findall(re.escape(' [')+"(.*)"+re.escape('] '),item)[0]
    post_request_type=re.findall(re.escape('"')+"(.*)"+re.escape('"'),item)[0]
    dict_log['host'] = IP
    dict_log['user_name'] = username
    dict_log['time'] = date
    dict_log['request'] = post_request_type
    list_all.append(dict_log.copy())
    dict_log.clear()
list_all

#PANDAS(to work on data-frames)
import pandas as pd
students = ["Alice", "Jack", "Moly"]                                  #using 'SERIES' function
pd.Series(students)                                                   #output- "Alice,Jack,Moly dtype: object", 1-D dataframe

numbers = [1, 2, 3,4]
pd.Series(numbers)

#Location function("iloc-index location", "loc-location")- this function only show the 'values' of the dictionary
import pandas as pd
students ={"Alice": "Physics", 
           "Jack": "Chemistry", 
           "Moly": "English", 
           "Sam": "History"}
df = pd.Series(students)                                              #'pd.DataFrame' function cannot be used since only 1 row is present, i.e. only 1 dictionary
df                                                                    #output- 'Alice      Physics, Jack     Chemistry, Moly       English, Sam        History, dtype: object'
df.iloc[3]                                                            #output- 'History'
df.loc["Sam"]                                                         #output- 'History'

#Simple loop to add numbers present in a series
grades = pd.Series( [90, 70, 80, 60] )
total = 0                                                             #initiate a varible where the sum will be stored
for i in grades:                                                      #'i' will be 90,70,80,60 respectively for each loop
    total = total+i
print(total)                                                          #output- '300'
#OR can be also directly be done using 'NUMPY'
import pandas as pd
import numpy as np
grades = pd.Series( [90, 70, 80, 60] )
total = np.sum(grades)
total

#DataFrame (using PANDAS)
import pandas as pd
r1 = pd.Series({"Name": "Alice", "Sub": "Physics", "Score": 85})
r2 = pd.Series({"Name": "Jack", "Sub": "Chemistry", "Score": 82})
r3 = pd.Series({"Name": "Helen", "Sub": "Biology", "Score": 90})
df = pd.DataFrame([r1, r2, r3], index = ["School 1", "School 2", "School 3"])        
print(df)                                                                     #can be directly created using a list where the values are dictionaries r1,r2,r3

df.iloc[2]                                                            #output- "Name       Helen Sub      Biology Score         90 Name: School 3, dtype: object"
df.loc["School 2"]                                                    #cannot mention 'Jack' insted of 'School 2', else error
df.loc["School 2"]["Name"]                                            #output- 'Jack'
df.drop("School 2")                                                   #Deletes entire row "School 2"
df["Ranking"] = ["2nd", "3rd", "1st" ]                                #ADDING a new 'Column' in the DataFrame

#Loading DataFrame from csv file
import pandas as pd
df = pd.read_csv("C:/Users/Administrator/Downloads/admission_predict.csv")
df.head()
df = pd.read_csv("C:/Users/Administrator/Downloads/admission_predict.csv", index_col = 0)                  #to set first column as index
df1 = df.rename(columns = {"GRE Score": "GRE", "University Rating": "UR"})                                 #renaming column names  

#DataFrame queries
mask = df["Chance of Admit "] > 0.7
mask                                                                  #will show only the chance of admit column, and shows 'True' for values which satisfies condtion & 'False' for others
df.where(mask)                                                        #Boolean mask using 'WHERE' function, shows 'NaN' values for entire row whose value is 'False' in above code
df.where(mask).dropna()                                               #removes the rows with 'NaN' values

#OR 'Boolean mask' can be directly applied using single code
df [df["Chance of Admit "] > 0.7]                                     #removes all rows that does not satisfies the condition

#Multiple condition
(df["Chance of Admit "] > 0.7) & (df["SOP"] > 4)                      #will show 'True' or 'False' for every index/rows 

#Indexing DataFrame
import pandas as pd
df = pd.read_csv("C:/Users/Administrator/Downloads/admission_predict.csv", index_col = 0) 
df.head(2)

#OR using 'set_index()' function
df = pd.read_csv("C:/Users/Administrator/Downloads/admission_predict.csv")
df.set_index("Serial No.").head(3)

#To 'RESET' index
df.reset_index().head(3)

df = df[df["University Rating"] == 5]                                 #applying a Boolean mask

#Multi-indexing
df["University Rating"].unique()                                      #shows different values that are present in the column 'University Rating', o/p- "array([4, 3, 2, 5, 1], dtype=int64)"
df = df.set_index(["University Rating", "Serial No."])                #multi-level indexing is set
df                                

#Taking 'census' DataFrame
import pandas as pd
df = pd.read_csv("C:/Users/Administrator/Downloads/census.csv")
df.head(3)

df["SUMLEV"].value_counts()                                           #to count number of different values present in a column

df = df[df["SUMLEV"] == 50]                                           #removing all rows, whose 'SUMLEV' value is other than 50 (i.e. removing 40)
df.head(5) 

#SELECTING only the 'COLUMNS' that we want to KEEP/SHOW
columns_to_keep = ['STNAME','CTYNAME','BIRTHS2010','BIRTHS2011','BIRTHS2012','BIRTHS2013','BIRTHS2014','BIRTHS2015',
                  'POPESTIMATE2010','POPESTIMATE2011','POPESTIMATE2012','POPESTIMATE2013','POPESTIMATE2014','POPESTIMATE2015']
df = df[columns_to_keep]
df.head(4)

df = df.set_index( ["STNAME", "CTYNAME"] )
df                                                                    #multi-indexing

df.loc[ [('Alabama', 'Baldwin County'), ('Wyoming', 'Weston County')] ]               #DataFrame querying

#Missing Values
import pandas as pd
df = pd.read_csv("C:/Users/Administrator/Downloads/class_grades.csv")                 #'class_grade' dataFrame is loaded
df.head(6)
df.dropna().head(6)                                                   #removes 'NaN' values

#Filling of 'NaN' values (fillna(), Forward filling & Backward filling)
df.fillna(0).head(6)                                                                  #'NaN' is given a value that is assigned by us
df.fillna(method = "ffill")                                           #Forward filling will assign the previous valid value to the 'NaN' values
df.fillna(method = "bfill")                                           #opposite of 'ffill', BEFORE USING 'ffill & bfill' data has to be sorted based on index, else not work

#Woking with 'log' dataset
import pandas as pd
df = pd.read_csv("C:/Users/Administrator/Downloads/log.csv")
df.head(5)

df.sort_index()                                                       #to 'SORT INDEX'
df.set_index(["user", "time"]).head(6)                                #multi-indexing

#Using 'REPLACE' function with help of 'Regex'
pattern = "[\w]*[.]html$"                                             #to search for the given pattern anywhere in the table, so column name need not be mentioned
df.replace(to_replace= pattern, value= "webpage", regex=True)         #replace the whole word which satisfies the pattern by the word 'webpage'

#Manipulating DataFrame
import pandas as pd
df = pd.read_csv("C:/Users/Administrator/Downloads/presidents.csv")
df.head(5)

df["Copy"] = df["President"]                                          #coping the value of the 'President' column into a new column called 'Copy'
df.head(5)

#Splitting the 'President' column into 'First' & 'Last' name using 'APPLY' function
def split_name (row):                                                 #function name is 'split_name', parameter name is 'row'
    row["First"] = row["President"].split(" ")[0]                     #split column 'President' into 2 parts from 'SPACE' and take the index '0'
    row["Last"] = row["President"].split(" ")[-1]                     #split column 'President' into 2 parts from 'SPACE' and take the index '-1'
    return row
df = df.apply(split_name, axis = 1)                                   #use of apply function on function 'split_name' (column-wise), insted of '1' we can also write 'columns'
df.head(5)

del(df["First"])                                    
del(df["Last"])                                                       #DELETING COLUMNS

#Applying Splitting using 'EXTRACT' FUNCTION
pattern = "(^[\w]*)(?:.* )([\w]*$)"                                   #group function is used(3 groups)
df["President"].str.extract(pattern).head()

#OR if we want to give names to our columns
pattern = "(?P<First>^[\w]*)(?:.* )(?P<Last>[\w]*$)"                  #"?P<name>" is for giving names to the column, rest all are the same 
n = df["President"].str.extract(pattern).head()
n                                                                     #prints only the 'First' & 'Last' column
df["First"] = n["First"]   
df["Last"] = n["Last"]                                                #copying rows 'First' & 'Last' into the main DataFrame 'df'
df.head()

#Format change of 'Date' in 'Born' column using 'to_datetime' function
pattern = "([\w]{3} [\w]{1,2}, [\w]{4})"                              #first bracket () is mandatory after ""
df["Born"] = df["Born"].str.extract(pattern)
df["Born"].head()
df["Born"] = pd.to_datetime(df["Born"])                               #using "pd.to_datetime function"
df["Born"].head(1)                                                    #output- "1732-02-22"





 

